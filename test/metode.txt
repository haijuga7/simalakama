-- FULL TELEPORT METHODS SCRIPT
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local metode = {}

-- FUNGSI VALIDASI UMUM
local function isValid(character, hrp)
    return character and character.Parent == workspace and 
           hrp and hrp.Parent == character and 
           hrp:IsA("BasePart")
end

-- METHOD 1: Simple CFrame (Paling Basic)
function metode.method1(character, hrp, targetPos)
    if not isValid(character, hrp) then return false end
    
    hrp.Anchored = false
    hrp.CFrame = CFrame.new(targetPos)
    task.wait(0.1)
    
    return isValid(character, hrp) and (hrp.Position - targetPos).Magnitude <= 5
end

-- METHOD 2: BodyPosition
function metode.method2(character, hrp, targetPos)
    if not isValid(character, hrp) then return false end
    
    local bp = Instance.new("BodyPosition")
    bp.Parent = hrp
    bp.MaxForce = Vector3.new(10000, 10000, 10000)
    bp.Position = targetPos
    
    task.wait(0.3)
    
    local success = isValid(character, hrp) and (hrp.Position - targetPos).Magnitude <= 5
    pcall(function() bp:Destroy() end)
    return success
end

-- METHOD 3: Weld + Anchor
function metode.method3(character, hrp, targetPos)
    if not isValid(character, hrp) then return false end
    
    local targetCFrame = CFrame.new(targetPos)
    hrp.Anchored = false
    hrp.CFrame = targetCFrame
    
    local anchorPart = Instance.new("Part")
    anchorPart.Size = Vector3.new(5, 1, 5)
    anchorPart.CFrame = hrp.CFrame * CFrame.new(0, -1, 0)
    anchorPart.Anchored = true
    anchorPart.CanCollide = false
    anchorPart.Transparency = 1
    anchorPart.Parent = workspace
    
    local weld = Instance.new("WeldConstraint")
    weld.Part0 = hrp
    weld.Part1 = anchorPart
    weld.Parent = hrp
    
    task.wait(0.2)
    
    local success = isValid(character, hrp) and (hrp.Position - targetPos).Magnitude <= 5
    
    pcall(function() weld:Destroy() end)
    pcall(function() anchorPart:Destroy() end)
    
    return success
end

-- METHOD 4: Seat Teleport
function metode.method4(character, hrp, targetPos)
    if not isValid(character, hrp) then return false end
    
    local targetCFrame = CFrame.new(targetPos)
    hrp.Anchored = false
    hrp.CFrame = targetCFrame
    
    local hrpPos = hrp.Position
    local closestSeat
    local closestDist = math.huge
    local searchRadius = 50
    
    local searchStart = tick()
    for _, seat in ipairs(workspace:GetDescendants()) do
        if tick() - searchStart > 1 then break end
        
        if (seat:IsA("Seat") or seat:IsA("VehicleSeat")) and seat.Parent then
            local dist = (seat.Position - hrpPos).Magnitude
            if dist < searchRadius and dist < closestDist then
                closestDist = dist
                closestSeat = seat
            end
        end
    end
    
    if not closestSeat then return false end
    
    if closestSeat.Occupant then
        local t0 = tick()
        while closestSeat.Occupant and tick() - t0 < 2 do
            task.wait(0.2)
        end
        if closestSeat.Occupant then return false end
    end
    
    local hum = character:FindFirstChildOfClass("Humanoid")
    if not hum or hum.Health <= 0 then return false end
    
    pcall(function() closestSeat:Sit(hum) end)
    task.wait(0.1)
    
    return isValid(character, hrp) and (hrp.Position - targetPos).Magnitude <= 5
end

-- METHOD 5: Rope/Rifle Method
function metode.method5(character, hrp, targetPos)
    if not isValid(character, hrp) then return false end
    
    local targetCFrame = CFrame.new(targetPos)
    hrp.Anchored = false
    hrp.CFrame = targetCFrame
    
    local rifle = workspace:FindFirstChild("RuntimeItems") and 
                  workspace.RuntimeItems:FindFirstChild("Bolt Action Rifle")
    
    if not rifle then return false end
    
    local bolt = rifle:FindFirstChild("Bolt")
    if not (bolt and bolt:IsA("BasePart") and bolt.Parent) then return false end
    
    local att0, att1, rope
    local success = pcall(function()
        att0 = Instance.new("Attachment", hrp)
        att1 = Instance.new("Attachment", bolt)
        rope = Instance.new("RopeConstraint")
        rope.Attachment0 = att0
        rope.Attachment1 = att1
        rope.Length = 0.1
        rope.Visible = false
        rope.Parent = hrp
    end)
    
    if not success then return false end
    
    task.wait(0.1)
    
    local result = isValid(character, hrp) and (hrp.Position - targetPos).Magnitude <= 5
    
    pcall(function() if rope then rope:Destroy() end end)
    pcall(function() if att0 then att0:Destroy() end end)
    pcall(function() if att1 then att1:Destroy() end end)
    
    return result
end

-- METHOD 6: Hook Teleport
function metode.method6(character, hrp, targetPos)
    if not isValid(character, hrp) then return false end
    if not hookfunction then return false end
    
    local targetCFrame = CFrame.new(targetPos)
    hrp.Anchored = false
    
    local oldTeleport
    local hookSuccess = pcall(function()
        oldTeleport = hookfunction(TeleportService.Teleport, function(...)
            return oldTeleport(...)
        end)
    end)
    
    if not hookSuccess then return false end
    
    hrp.CFrame = targetCFrame
    task.wait(0.1)
    
    return isValid(character, hrp) and (hrp.Position - targetPos).Magnitude <= 5
end

-- METHOD 7: Hook TeleportAsync
function metode.method7(character, hrp, targetPos)
    if not isValid(character, hrp) then return false end
    if not hookfunction then return false end
    
    local targetCFrame = CFrame.new(targetPos)
    hrp.Anchored = false
    
    local oldTeleportAsync
    local hookSuccess = pcall(function()
        oldTeleportAsync = hookfunction(TeleportService.TeleportAsync, function(...)
            return oldTeleportAsync(...)
        end)
    end)
    
    if not hookSuccess then return false end
    
    hrp.CFrame = targetCFrame
    task.wait(0.1)
    
    return isValid(character, hrp) and (hrp.Position - targetPos).Magnitude <= 5
end

-- METHOD 8: Hook LoadCharacter
function metode.method8(character, hrp, targetPos)
    if not isValid(character, hrp) then return false end
    if not hookfunction then return false end
    
    local targetCFrame = CFrame.new(targetPos)
    hrp.Anchored = false
    
    local oldLoadCharacter
    local hookSuccess = pcall(function()
        oldLoadCharacter = hookfunction(LocalPlayer.LoadCharacter, function(...)
            return oldLoadCharacter(...)
        end)
    end)
    
    if not hookSuccess then return false end
    
    hrp.CFrame = targetCFrame
    task.wait(0.1)
    
    return isValid(character, hrp) and (hrp.Position - targetPos).Magnitude <= 5
end

-- METHOD 9: NoClip + BodyVelocity
function metode.method9(character, hrp, targetPos)
    if not isValid(character, hrp) then return false end
    
    local targetCFrame = CFrame.new(targetPos)
    hrp.Anchored = false
    
    local NoclipConnection
    local function noclipFunc()
        if not isValid(character, hrp) then
            if NoclipConnection then NoclipConnection:Disconnect() end
            return
        end
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end
    
    NoclipConnection = RunService.Stepped:Connect(noclipFunc)
    
    local bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(1e6, 1e6, 1e6)
    bv.Velocity = (targetPos - hrp.Position).Unit * 100
    bv.Parent = hrp
    
    local startTime = tick()
    local success = false
    
    while tick() - startTime < 2 do
        if not isValid(character, hrp) then break end
        
        bv.Velocity = (targetPos - hrp.Position).Unit * 100
        
        if (hrp.Position - targetPos).Magnitude <= 5 then
            success = true
            break
        end
        task.wait(0.1)
    end
    
    pcall(function() bv:Destroy() end)
    
    if NoclipConnection then
        NoclipConnection:Disconnect()
    end
    
    if isValid(character, hrp) then
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
    
    return success
end

-- METHOD 10: Tween
function metode.method10(character, hrp, targetPos)
    if not isValid(character, hrp) then return false end
    
    local targetCFrame = CFrame.new(targetPos)
    hrp.Anchored = false
    
    local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Linear)
    local tween = TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
    
    tween:Play()
    
    local startTime = tick()
    while tick() - startTime < 1.5 do
        if not isValid(character, hrp) then
            pcall(function() tween:Cancel() end)
            return false
        end
        
        if (hrp.Position - targetPos).Magnitude <= 5 then
            break
        end
        task.wait(0.1)
    end
    
    return isValid(character, hrp) and (hrp.Position - targetPos).Magnitude <= 5
end

-- METHOD 11: PivotTo
function metode.method11(character, hrp, targetPos)
    if not isValid(character, hrp) then return false end
    
    local targetCFrame = CFrame.new(targetPos)
    hrp.Anchored = false
    
    if not character.PivotTo then return false end
    
    local success = pcall(function()
        character:PivotTo(targetCFrame)
    end)
    
    if not success then return false end
    
    task.wait(0.1)
    
    return isValid(character, hrp) and (hrp.Position - targetPos).Magnitude <= 5
end

-- METHOD 12: SetPrimaryPartCFrame
function metode.method12(character, hrp, targetPos)
    if not isValid(character, hrp) then return false end
    
    local targetCFrame = CFrame.new(targetPos)
    hrp.Anchored = false
    
    local oldPrimary = character.PrimaryPart
    
    local success = pcall(function()
        character.PrimaryPart = hrp
        character:SetPrimaryPartCFrame(targetCFrame)
    end)
    
    if oldPrimary then
        pcall(function() character.PrimaryPart = oldPrimary end)
    end
    
    if not success then return false end
    
    task.wait(0.1)
    
    return isValid(character, hrp) and (hrp.Position - targetPos).Magnitude <= 5
end

-- METHOD 13: Network Owner
function metode.method13(character, hrp, targetPos)
    if not isValid(character, hrp) then return false end
    
    local targetCFrame = CFrame.new(targetPos)
    hrp.Anchored = false
    
    if not hrp.SetNetworkOwner then return false end
    
    pcall(function()
        hrp:SetNetworkOwner(LocalPlayer)
    end)
    
    hrp.CFrame = targetCFrame
    task.wait(0.1)
    
    return isValid(character, hrp) and (hrp.Position - targetPos).Magnitude <= 5
end

-- METHOD 14: Hook __index
function metode.method14(character, hrp, targetPos)
    if not isValid(character, hrp) then return false end
    if not hookmetamethod then return false end
    
    local targetCFrame = CFrame.new(targetPos)
    hrp.Anchored = false
    
    local oldIndex
    local hookSuccess = pcall(function()
        oldIndex = hookmetamethod(game, "__index", function(obj, key)
            return oldIndex(obj, key)
        end)
    end)
    
    if not hookSuccess then return false end
    
    hrp.CFrame = targetCFrame
    task.wait(0.1)
    
    return isValid(character, hrp) and (hrp.Position - targetPos).Magnitude <= 5
end

-- METHOD 15: Gravity Disable
function metode.method15(character, hrp, targetPos)
    if not isValid(character, hrp) then return false end
    
    local targetCFrame = CFrame.new(targetPos)
    hrp.Anchored = false
    
    local oldGrav = workspace.Gravity
    workspace.Gravity = 0
    
    local bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(1e6, 1e6, 1e6)
    bv.Velocity = (targetPos - hrp.Position).Unit * 50
    bv.Parent = hrp
    
    local startTime = tick()
    local success = false
    
    while tick() - startTime < 2 do
        if not isValid(character, hrp) then break end
        
        bv.Velocity = (targetPos - hrp.Position).Unit * 50
        
        if (hrp.Position - targetPos).Magnitude <= 5 then
            success = true
            break
        end
        task.wait(0.1)
    end
    
    pcall(function() bv:Destroy() end)
    workspace.Gravity = oldGrav or 196.2
    
    return success
end

-- METHOD 16: VectorForce Method
function metode.method16(character, hrp, targetPos)
    if not isValid(character, hrp) then return false end
    
    local targetCFrame = CFrame.new(targetPos)
    hrp.Anchored = false
    
    local vectorForce = Instance.new("VectorForce")
    vectorForce.Force = Vector3.new(0, 0, 0)
    vectorForce.ApplyAtCenterOfMass = true
    vectorForce.RelativeTo = Enum.ActuatorRelativeTo.World
    vectorForce.Parent = hrp
    
    local bv = Instance.new("BodyVelocity")
    bv.Velocity = (targetPos - hrp.Position).Unit * 100
    bv.MaxForce = Vector3.new(400000, 400000, 400000)
    bv.Parent = hrp
    
    local startTime = tick()
    local success = false
    
    while tick() - startTime < 2 do
        if not isValid(character, hrp) then break end
        bv.Velocity = (targetPos - hrp.Position).Unit * 100
        
        if (hrp.Position - targetPos).Magnitude <= 5 then
            success = true
            break
        end
        task.wait()
    end
    
    pcall(function() vectorForce:Destroy() end)
    pcall(function() bv:Destroy() end)
    
    return success
end

-- METHOD 17: Rocket Propulsion Method
function metode.method17(character, hrp, targetPos)
    if not isValid(character, hrp) then return false end
    
    hrp.Anchored = false
    
    local rocket = Instance.new("RocketPropulsion")
    rocket.Target = hrp
    rocket.TargetOffset = Vector3.new(0, 0, 0)
    rocket.MaxSpeed = 100
    rocket.MaxThrust = 100000
    rocket.CartoonFactor = 1
    rocket.Parent = hrp
    
    local targetPart = Instance.new("Part")
    targetPart.Size = Vector3.new(1, 1, 1)
    targetPart.Position = targetPos
    targetPart.Anchored = true
    targetPart.CanCollide = false
    targetPart.Transparency = 1
    targetPart.Parent = workspace
    
    rocket.Target = targetPart
    rocket:Fire()
    
    local startTime = tick()
    local success = false
    
    while tick() - startTime < 3 do
        if not isValid(character, hrp) then break end
        if (hrp.Position - targetPos).Magnitude <= 5 then
            success = true
            rocket:Abort()
            break
        end
        task.wait(0.1)
    end
    
    pcall(function() rocket:Destroy() end)
    pcall(function() targetPart:Destroy() end)
    
    return success
end

-- METHOD 18: BodyGyro + BodyPosition Combo
function metode.method18(character, hrp, targetPos)
    if not isValid(character, hrp) then return false end
    
    hrp.Anchored = false
    
    local bp = Instance.new("BodyPosition")
    bp.Position = targetPos
    bp.MaxForce = Vector3.new(400000, 400000, 400000)
    bp.P = 10000
    bp.D = 1000
    bp.Parent = hrp
    
    local bg = Instance.new("BodyGyro")
    bg.MaxTorque = Vector3.new(400000, 400000, 400000)
    bg.P = 10000
    bg.D = 1000
    bg.Parent = hrp
    
    task.wait(0.5)
    
    local success = isValid(character, hrp) and (hrp.Position - targetPos).Magnitude <= 5
    
    pcall(function() bp:Destroy() end)
    pcall(function() bg:Destroy() end)
    
    return success
end

-- METHOD 19: AlignPosition Constraint
function metode.method19(character, hrp, targetPos)
    if not isValid(character, hrp) then return false end
    
    hrp.Anchored = false
    
    local targetAttachment = Instance.new("Attachment")
    targetAttachment.Parent = hrp
    
    local alignPos = Instance.new("AlignPosition")
    alignPos.Attachment0 = targetAttachment
    alignPos.MaxForce = 100000
    alignPos.Responsiveness = 200
    alignPos.RigidityEnabled = false
    alignPos.Parent = hrp
    
    local targetPart = Instance.new("Part")
    targetPart.Size = Vector3.new(1, 1, 1)
    targetPart.Position = targetPos
    targetPart.Anchored = true
    targetPart.CanCollide = false
    targetPart.Transparency = 1
    targetPart.Parent = workspace
    
    local targetAttach = Instance.new("Attachment")
    targetAttach.Parent = targetPart
    
    alignPos.Attachment1 = targetAttach
    
    task.wait(0.8)
    
    local success = isValid(character, hrp) and (hrp.Position - targetPos).Magnitude <= 5
    
    pcall(function() alignPos:Destroy() end)
    pcall(function() targetAttachment:Destroy() end)
    pcall(function() targetPart:Destroy() end)
    
    return success
end

-- METHOD 20: Spring Constraint Method
function metode.method20(character, hrp, targetPos)
    if not isValid(character, hrp) then return false end
    
    hrp.Anchored = false
    
    local anchorPart = Instance.new("Part")
    anchorPart.Size = Vector3.new(1, 1, 1)
    anchorPart.Position = targetPos
    anchorPart.Anchored = true
    anchorPart.CanCollide = false
    anchorPart.Transparency = 1
    anchorPart.Parent = workspace
    
    local spring = Instance.new("SpringConstraint")
    spring.Attachment0 = Instance.new("Attachment", hrp)
    spring.Attachment1 = Instance.new("Attachment", anchorPart)
    spring.Stiffness = 10000
    spring.Damping = 1000
    spring.FreeLength = 0.1
    spring.Parent = hrp
    
    task.wait(0.6)
    
    local success = isValid(character, hrp) and (hrp.Position - targetPos).Magnitude <= 5
    
    pcall(function() spring:Destroy() end)
    pcall(function() anchorPart:Destroy() end)
    
    return success
end

-- METHOD 21: BodyThrust Method
function metode.method21(character, hrp, targetPos)
    if not isValid(character, hrp) then return false end
    
    hrp.Anchored = false
    
    local thrust = Instance.new("BodyThrust")
    thrust.Force = (targetPos - hrp.Position).Unit * 10000
    thrust.Location = Vector3.new(0, 0, 0)
    thrust.Parent = hrp
    
    local startTime = tick()
    local success = false
    
    while tick() - startTime < 2 do
        if not isValid(character, hrp) then break end
        thrust.Force = (targetPos - hrp.Position).Unit * 10000
        
        if (hrp.Position - targetPos).Magnitude <= 5 then
            success = true
            break
        end
        task.wait()
    end
    
    pcall(function() thrust:Destroy() end)
    return success
end

-- METHOD 22: BodyAngularVelocity Spin Teleport
function metode.method22(character, hrp, targetPos)
    if not isValid(character, hrp) then return false end
    
    hrp.Anchored = false
    
    local bav = Instance.new("BodyAngularVelocity")
    bav.AngularVelocity = Vector3.new(0, 50, 0)
    bav.MaxTorque = Vector3.new(100000, 100000, 100000)
    bav.Parent = hrp
    
    local bv = Instance.new("BodyVelocity")
    bv.Velocity = (targetPos - hrp.Position).Unit * 80
    bv.MaxForce = Vector3.new(400000, 400000, 400000)
    bv.Parent = hrp
    
    task.wait(0.4)
    
    local success = isValid(character, hrp) and (hrp.Position - targetPos).Magnitude <= 5
    
    pcall(function() bav:Destroy() end)
    pcall(function() bv:Destroy() end)
    
    return success
end

-- METHOD 23: CFrame Interpolation (Smooth)
function metode.method23(character, hrp, targetPos)
    if not isValid(character, hrp) then return false end
    
    local startPos = hrp.Position
    local duration = 1
    local startTime = tick()
    
    hrp.Anchored = false
    
    local connection
    connection = RunService.Heartbeat:Connect(function()
        if not isValid(character, hrp) then
            connection:Disconnect()
            return
        end
        
        local elapsed = tick() - startTime
        local alpha = math.min(elapsed / duration, 1)
        
        local smoothAlpha = alpha * alpha * (3 - 2 * alpha)
        local currentPos = startPos:Lerp(targetPos, smoothAlpha)
        
        hrp.CFrame = CFrame.new(currentPos)
        
        if alpha >= 1 then
            connection:Disconnect()
        end
    end)
    
    task.wait(duration + 0.1)
    
    if connection and connection.Connected then
        connection:Disconnect()
    end
    
    return isValid(character, hrp) and (hrp.Position - targetPos).Magnitude <= 5
end

-- METHOD 24: Magnetic Field Method
function metode.method24(character, hrp, targetPos)
    if not isValid(character, hrp) then return false end
    
    hrp.Anchored = false
    
    local targetPart = Instance.new("Part")
    targetPart.Size = Vector3.new(10, 10, 10)
    targetPart.Position = targetPos
    targetPart.Anchored = true
    targetPart.CanCollide = false
    targetPart.Transparency = 1
    targetPart.Parent = workspace
    
    local magneticField = Instance.new("VectorForce")
    magneticField.Name = "MagneticField"
    magneticField.ApplyAtCenterOfMass = true
    magneticField.RelativeTo = Enum.ActuatorRelativeTo.World
    magneticField.Force = Vector3.new(0, 0, 0)
    magneticField.Parent = hrp
    
    local startTime = tick()
    local success = false
    
    while tick() - startTime < 2 do
        if not isValid(character, hrp) then break end
        
        local direction = (targetPos - hrp.Position).Unit
        local distance = (targetPos - hrp.Position).Magnitude
        local force = math.min(10000 / (distance + 1), 10000)
        
        magneticField.Force = direction * force
        
        if distance <= 5 then
            success = true
            break
        end
        task.wait()
    end
    
    pcall(function() magneticField:Destroy() end)
    pcall(function() targetPart:Destroy() end)
    
    return success
end

-- METHOD 25: Multiple BodyForces Method
function metode.method25(character, hrp, targetPos)
    if not isValid(character, hrp) then return false end
    
    hrp.Anchored = false
    
    local antiGravity = Instance.new("BodyForce")
    antiGravity.Force = Vector3.new(0, workspace.Gravity * hrp:GetMass(), 0)
    antiGravity.Parent = hrp
    
    local movementForce = Instance.new("BodyForce")
    movementForce.Force = (targetPos - hrp.Position).Unit * 10000
    movementForce.Parent = hrp
    
    local startTime = tick()
    local success = false
    
    while tick() - startTime < 2 do
        if not isValid(character, hrp) then break end
        movementForce.Force = (targetPos - hrp.Position).Unit * 10000
        
        if (hrp.Position - targetPos).Magnitude <= 5 then
            success = true
            break
        end
        task.wait()
    end
    
    pcall(function() antiGravity:Destroy() end)
    pcall(function() movementForce:Destroy() end)
    
    return success
end

-- METHOD 26: Physics Service Collision Groups
function metode.method26(character, hrp, targetPos)
    if not isValid(character, hrp) then return false end
    
    local PhysicsService = game:GetService("PhysicsService")
    
    local groupName = "TeleportGroup_" .. tostring(tick())
    local success = pcall(function()
        PhysicsService:CreateCollisionGroup(groupName)
        PhysicsService:CollisionGroupSetCollidable(groupName, "Default", false)
        
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CollisionGroup = groupName
            end
        end
    end)
    
    if not success then return false end
    
    hrp.Anchored = false
    hrp.CFrame = CFrame.new(targetPos)
    task.wait(0.2)
    
    pcall(function()
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CollisionGroup = "Default"
            end
        end
        PhysicsService:RemoveCollisionGroup(groupName)
    end)
    
    return isValid(character, hrp) and (hrp.Position - targetPos).Magnitude <= 5
end


return metode
